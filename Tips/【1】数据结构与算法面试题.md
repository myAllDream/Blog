[TOC]

# 数据结构与算法

## 一、概念性

### 【2】怎么理解数据结构？

> 思路：数据结构的定义、分类
>
> 参考回答：研究数据的逻辑结构和物理结构以及它们之间相互关系，并对这种结构定义相应的运算，而且确保经过这些运算后所得到的新结构仍然是原来的结构类型。
>
> - 按照逻辑结构分类
>   - 线性结构：线性表、栈、队列
>   - 非线性结构：树、图
> - 按照存储结构分为顺序结构、链式结构、索引结构、哈希结构



### 【2】迭代和递归的特点，并比较优缺点

> - 技术点：递归和循环
> - 参考回答：递归和迭代都是循环的一种，特点：
>   - 递归就是通过重复调用函数自身实现循环；满足终止条件时会逐层返回来结束循环
>   - 迭代通过函数内某段代码实现循环；使用计数器结束循环

|      | 优点                         | 缺点                                                         |
| ---- | ---------------------------- | ------------------------------------------------------------ |
| 递归 | 代码更简洁清晰，可读性更好   | 需要调用函数，会造成空间的浪费；使用栈机制，循环次数太多易造成堆栈溢出 |
| 迭代 | 效率高；无额外开销，节省空间 | 代码不如递归简洁                                             |



### 【3】了解哪些查找算法，时间复杂度都是多少？

| 查找                 | 平均时间复杂度 | 查找条件               | 算法描述                                                     |
| -------------------- | -------------- | ---------------------- | ------------------------------------------------------------ |
| 顺序查找             | O(n)           | 无序或有序队列         | 按顺序比较每个元素，直到找到关键字为止                       |
| 二分查找（折半查找） | O(logn)        | 有序数组               | 查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。　如果在某一步骤数组为空，则代表找不到。 |
| 二叉排序树查找       | O(logn)        | 二叉排序树             | 在二叉查找树b中查找x的过程为：1. 若b是空树，则搜索失败2. 若x等于b的根节点的数据域之值，则查找成功；3. 若x小于b的根节点的数据域之值，则搜索左子树4. 查找右子树。 |
| 哈希表法（散列表）   | O(1)           | 先创建哈希表（散列表） | 根据键值方式(Key value)进行查找，通过散列函数，定位数据元素。 |
| 分块查找             | O(logn)        | 无序或有序队列         | 将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。然后使用二分查找及顺序查找。 |



### 【4】了解哪些排序算法，并比较一下，以及适用场景

![排序算法复杂度](http://r.photo.store.qq.com/psb?/V14L47VC0w3vOf/VZ4iMbv5C*wHe7ZkHrr8ET.WQQbZJhw.luEFOYCg4YU!/r/dLkAAAAAAAAA)

| 名称     | 特点                                                         | 适用                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 冒泡     | 重复走访要排序的数列，一次比较两个元素，若较小元素在后则交换，能看到越小的元素会经由交换慢慢浮到数列的顶端 | 数据规模较小                                                 |
| 简单选择 | 每次都在未排序序列中找最小元素                               | 数据规模较小且对稳定性有要求                                 |
| 直接插入 | 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入 | 数据规模较小且待排序列基本有序                               |
| 希尔     | 将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序 | 数据规模较大                                                 |
| 归并     | 先使每个子序列有序，再使子序列段间有序                       | 数据规模较大且对稳定性有要求                                 |
| 堆       | 近似完全二叉树的结构，子结点的键值或索引总是小于（或大于）其父节点 | 数据规模较大，相比快排好处是不会出现最坏情况、需要的辅助空间少 |
| 快速     | 取一个记录作为枢轴，经过一趟排序将整段序列分为两个部分，使得数轴左侧都小于枢轴、右侧都大于枢轴；再对这两部分继续进行排序使整个序列达到有序 | 数据规模较大且待排序列无序                                   |



### 【5】快排的基本思路是什么？最差的时间复杂度是多少？如何优化？

> 快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小；再分别对这两部分记录继续进行排序，以达到整个序列有序的目的。当待排序列有序时会出现最坏时间复杂度O(n^2)。几种优化方式：
>
> > 快速排序的最好情况： 
> > 快速排序的最好情况是每次都划分后左右子序列的大小都相等，其运行的时间就为O(N*logN)
> >
> > 快速排序的最坏情况： 
> > 快速排序的最坏的情况就是完全正序或者倒序，这时候其运行时间就变为O(N*N)
> >
> > 快速排序的平均情况： 
> >
> > 平均情况下是O(N*logN)
>
> - 当待排序序列的长度较小时采用直接插入排序
> - 优化所选取数轴的计算方法，如三数取中
> - 迭代取代递归，效率高
> - 存储数轴值，节省无必要的交换
>
> [推荐阅读](https://www.cnblogs.com/penghuwan/p/7883076.html?utm_source=tuicool&utm_medium=referral)



### 【6】什么是红黑树？

> 红黑树是一种自平衡二叉查找树，包含性质：
>
> - 节点是红色或黑色
> - 根节点是黑色
> - 叶子节点是黑色
> - 每个红色节点的两个子节点都是黑色
> - 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点



### 【7】海量数据处理

> - 技术点：海量数据问题
> - 思路：分治、哈希、bit、堆
> - 参考回答：[海量数据处理面试题集锦](https://blog.csdn.net/v_july_v/article/details/6685962)



## 二、排序

- [博客园图解排序](https://www.cnblogs.com/chengxiao/p/6129630.html)

### 【1】冒泡排序

> 比较两个相邻的元素，将值大的元素交换至右端。 就像冒泡一样，一个泡从水底逐渐冒上来。

```java
 public static void main(String[] args) {
        int bubblesort[]= new int[]{12, 33, 5, 8, 67};
        for(int i=0;i<bubblesort.length-1;i++){//外层循环控制循环趟数
            for (int j=0;j<bubblesort.length-1-i;j++){//内层循环控制每个泡冒到顶上比较的次数
                if(bubblesort[j]>bubblesort[j+1]){
                    int temp=bubblesort[j+1];
                    bubblesort[j+1]=bubblesort[j];
                    bubblesort[j]=temp;
                }
            }
        }
       System.out.println(Arrays.toString(bubblesort));
    }

//输出：
[5, 8, 12, 33, 67]

//优化1：连片有序整体无序
void BubbleSort(int arr[], int len)
{
    int flag = 0;
    for (int i = 0; i < len - 1; i++)//确定排序趟数
    {
        flag=0; //置为0*********************************
        for (int j = 0; j < len - 1 - i; j++)//确定比较次数
        {
                if (arr[j]>arr[j + 1])
            {
                //交换
                int tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
                flag = 1;//加入标记*********************************
            }
        }
        if (flag == 0)//如果没有交换过元素，则已经有序*****************************
        {
            break;
        }
    }
}

//优化2：前大半部分无序，后小半部分有序
void BubbleSort(int arr[], int len)
{
    int i = 0;
    int tmp = 0;
    int flag = 0;
    int pos = 0;//用来记录最后一次交换的位置*******************************
    int k = len - 1;
    for (i = 0; i < len - 1; i++)//确定排序趟数
    {
        flag = 0;
        pos = 0;	//+++++++++++++++++++++++++++++++++
        for (int j = 0; j < k; j++)//确定比较次数+++++++++++++++++++++++++++
        {
            if (arr[j]>arr[j + 1])
            {
                //交换
                tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
                flag = 1;//加入标记
                pos = j;//交换元素，记录最后一次交换的位置****************************
            }
        }
        if (flag == 0)//如果没有交换过元素，则已经有序
        {
            break;
        }
        k = pos;//下一次比较到记录位置即可 +++++++++++++++++++++++++++++++++
    }
}
```



### 【2】快速排序

```java
public class QuickSort {
    public static void main(String[] args) {
        int[] a={1,5,2,4,6,7};
        quickSort(a,0,a.length-1);
        System.out.println(Arrays.toString(a));
    }

    static void quickSort(int[] array, int left, int right) {
        if (array != null || array.length >= 1) {

            int temp = array[left];//基准数
            int i = left;
            int j = right;
            int swap;

            while (i != j) {
                //顺序很重要，要先从右边开始找
                while (array[j] >= temp && i < j) {
                    j--;
                }
                //再找右边的
                while (array[i] <= temp && i < j) {
                    i++;
                }
                //交换两个数在数组中的位置
                if (i < j) {
                    swap = array[i];
                    array[i] = array[j];
                    array[j] = swap;
                }
            }

            //最终将基准数归位
            array[left] = array[i];
            array[i] = temp;
            if (i>left)
            quickSort(array, left, i - 1);//继续处理左边的，这里是一个递归的过程
            if (j<right)
            quickSort(array, i + 1, right);//继续处理右边的 ，这里是一个递归的过程
        }
    }
}
```



### 【3】堆排序

```java
//构建大根堆：将array看成完全二叉树的顺序存储结构
    private int[] buildMaxHeap(int[] array){
        //从最后一个节点array.length-1的父节点（array.length-1-1）/2开始，直到根节点0，反复调整堆
        for(int i= array.length/2-1 ; i>=0 ;i--){ 
            adjustDownToUp(array, i,array.length);
        }
        return array;
    }
    
    //将元素array[k]自下往上逐步调整树形结构
    private void adjustDownToUp(int[] array,int k,int length){
        int temp = array[k];   
        for(int i=2*k+1; i<length-1; i=2*i+1){    //i为初始化为节点k的左孩子，沿节点较大的子节点向下调整
            if(i<length && array[i]<array[i+1]){  //取节点较大的子节点的下标
                i++;   //如果节点的右孩子>左孩子，则取右孩子节点的下标
            }
            if(temp>=array[i]){  //根节点 >=左右子女中关键字较大者，调整结束
                break;
            }else{   //根节点 <左右子女中关键字较大者
                array[k] = array[i];  //将左右子结点中较大值array[i]调整到双亲节点上
                k = i; //【关键】修改k值，以便继续向下调整
            }
        }
        array[k] = temp;  //被调整的结点的值放人最终位置
    }

//堆排序
    public int[] heapSort(int[] array){
        array = buildMaxHeap(array); //初始建堆，array[0]为第一趟值最大的元素
        for(int i=array.length-1;i>1;i--){  
            int temp = array[0];  //将堆顶元素和堆低元素交换，即得到当前最大元素正确的排序位置
            array[0] = array[i];
            array[i] = temp;
            adjustDownToUp(array, 0,i);  //整理，将剩余的元素整理成堆
        }
        return array;
    }
```



## 三、查找

### 【1】二分查找

```java
public static int binarySearch(int[] a, int key) {
    int low, mid, high;
    low = 0;//最小下标
    high = a.length - 1;//最大小标
    while (low <= high) {
        mid = (high + low) / 2;//折半下标
        if (key > a[mid]) {
            low = mid + 1; //关键字比折半值大，则最小下标调成折半下标的下一位
        } else if (key < a[mid]) {
            high = mid - 1;//关键字比折半值小，则最大下标调成折半下标的前一位
        } else {
            return mid; //关键字和折半值相等时返回折半下标
        }
    }
    return -1;
}
```



## 四、Java多线程

### 【1】用三个线程，顺序打印字母A-Z

> - 题目：用三个线程，顺序打印字母A-Z，输出结果是1A、2B、3C、1D 2E...
> - 思路：加锁进行限制，并配合wait()和notifyAll()

```java
private static char c = 'A';
private static int i = 0;
public static void main(String[] args) {        
    Runnable runnable = new Runnable() {
           public void run() {
              synchronized (this) {//加锁
                try {
                    int threadId = Integer.parseInt(Thread.currentThread().getName());
                    while (i < 26) {
                        //关键代码
                         if (i % 3 == threadId - 1) {
                             System.out.println(threadId +""+ (char) c++);
                             i++;
                             notifyAll();// 唤醒处于等待状态的线程
                         } else {
                             wait();// 释放当前锁并进入等待状态
                         }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
              }//执行结束释放当前锁
           }
        };
        Thread t1 = new Thread(runnable, "1");
        Thread t2 = new Thread(runnable, "2");
        Thread t3 = new Thread(runnable, "3");
        t1.start();
        t2.start();
        t3.start();
}
```



### 【2】基本生产者消费者

```java
public class ProducerConsumerWithWaitNofity {
    public static void main(String[] args) {
        Resourse resourse = new Resourse();
        Consumer consumer = new Consumer(resourse);
        Consumer consumer1 = new Consumer(resourse);
        Producer producer = new Producer(resourse);
        Producer producer1 = new Producer(resourse);
        consumer.start();
        consumer1.start();
        producer.start();
        producer1.start();
    }
}

class Resourse {
    private int count = 0;
    private int max = 10;

    public synchronized void add() throws InterruptedException {
        if (count < max) {
            count++;
            System.out.println(Thread.currentThread().getName() + "生产一件资源，当前资源池有"
                    + count + "个");
            notifyAll();
        } else {
            wait();
            System.out.println(Thread.currentThread().getName()+"线程进入等待");
        }
    }

    public synchronized void remove() throws InterruptedException {
        if (count > 0) {
            count--;
            System.out.println("消费者" + Thread.currentThread().getName() +
                    "消耗一件资源，" + "当前线程池有" + count + "个");
            notifyAll();
        } else {
            wait();
            System.out.println("消费者" + Thread.currentThread().getName() + "线程进入等待状态");
        }
    }
}

class Consumer extends Thread {
    private Resourse resource;

    Consumer(Resourse resource) {
        this.resource = resource;
    }

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            try {
                resource.remove();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class Producer extends Thread {
    private Resourse resource;

    Producer(Resourse resource) {
        this.resource = resource;
    }

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            try {
                resource.add();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```



### 【3】5个线程先打印Hello再打印World

> countDownLatch.countDown();计数器加1
>
>  countDownLatch.await();等待

```java
public class FiveThreadCommunication {

    private static final int MAX_THREAD = 5;

    private static final class PrintRunnable implements Runnable {

        private final CountDownLatch countDownLatch;

        public PrintRunnable(CountDownLatch countDownLatch) {
            this.countDownLatch = countDownLatch;
        }

        @Override
        public void run() {
            System.out.println("Thread-" + Thread.currentThread().getId() + " Hello");
            countDownLatch.countDown();
            try {
                countDownLatch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread-" + Thread.currentThread().getId() + " World");
        }

    }


    public static void main(String args[]) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(MAX_THREAD);
        for (int i = 0; i < MAX_THREAD; i++) {
            new Thread(new PrintRunnable(countDownLatch)).start();
        }
    }


}
```



### 【4】写一个简单的死锁

> 两个线程争资源

```java
public class DeadLock {
    public static String obj1 = "obj1";
    public static String obj2 = "obj2";
    public static void main(String[] args){
        Thread a = new Thread(new Lock1());
        Thread b = new Thread(new Lock2());
        a.start();
        b.start();
    }    
}
class Lock1 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock1 running");
            while(true){
                synchronized(DeadLock.obj1){
                    System.out.println("Lock1 lock obj1");
                    Thread.sleep(3000);//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2
                    synchronized(DeadLock.obj2){
                        System.out.println("Lock1 lock obj2");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
class Lock2 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock2 running");
            while(true){
                synchronized(DeadLock.obj2){
                    System.out.println("Lock2 lock obj2");
                    Thread.sleep(3000);
                    synchronized(DeadLock.obj1){
                        System.out.println("Lock2 lock obj1");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```





## 五、剑指Offer

### 1、数据结构与算法操作

#### 递归和循环

##### 【1】斐波那契数列

```java
//递归版
long fibonacci(int n) {
        if (n == 1) {
            return 0;
        } else if (n == 2) {
            return 1L;
        }
        return fibonacci(n - 1) + fibonacci(n - 1);
    }
//循环版
long fibonacci(int n) {
        int result[] = {0, 1};
        if (n <= 2) {
            return result[n];
        }

        long fibOne = 0;
        long fibTwo = 1;
        long finResult = 0;
        for (int i = 3; i <= n; i++) {
            finResult = fibOne + fibTwo;
            fibOne = fibTwo;
            fibTwo = finResult;
        }
        return finResult;
    }
```



#### 栈和队列

##### 【1】最小栈

> - **题目：**定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度为O（1）
> - **思路：**
>   - 重复压栈，当前最小值地下总是压着一个上一次最小值
>     - 输入：2 8 6 1 4 
>     - 栈内：【MAX 2】 8 6 【2 1】 4 
>   - 利用辅助栈: s1主栈，s2最小值栈[存储最小值]
>     - 输入：2 8 6 1 4 
>     - S1栈内：2 8 6  1 4 
>     - S2栈内：2 1
> - 自定义一个最小元素栈，进行push操作时, 如果压入的元素小于等于栈顶元素, 则压入最小元素栈；进行pop操作时, 如果弹出的元素和栈顶元素相等, 就把最小元素栈顶也弹出。

```java
//重复压栈
public class MinStack {
    //保存最小值
    private int min_val = Integer.MAX_VALUE;
    private Stack<Integer> s = new Stack<>();
    
    /** initialize your data structure here. */
    public MinStack() {}
    
    public void push(int x) {
        //重复压栈操作
        if (x <= min_val) {
            s.push(min_val);
            min_val = x;
        }
        s.push(x);
    }
    
    public void pop() {
        //如果弹出的是最小元素
        if (s.pop() == min_val) 
            //改变当前最小值
            min_val = s.pop();
    }
    
    public int top() {
        return s.peek();
    }
    
    public int getMin() {
        return min_val;
    }
}

//利用两个栈: s1主栈，s2最小值栈
public class MinStack {
    private Stack<Integer> s1 = new Stack<>();
    private Stack<Integer> s2 = new Stack<>();
    
    /** initialize your data structure here. */
    public MinStack() {}
    
    public void push(int x) {
        s1.push(x);
        //如果s2位空或者将要push的数字比s2栈顶的数字小，那么也压入s2一份
        if (s2.isEmpty() || s2.peek() >= x) 
            s2.push(x);
    }
    
    public void pop() {
        // Cannot write like the following:
        // if (s2.peek() == s1.peek()) s2.pop();
        // s1.pop();
        int x = s1.pop();
        if (s2.peek() == x) 
            s2.pop();
    }
    
    public int top() {
        return s1.peek();
    }
    
    public int getMin() {
        return s2.peek();
    }
}
```



##### 【2】栈弹出顺序

> - **题目：**输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压入顺序，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，而4、3、5、1、2不可能是该压栈序列的弹出序列。
> - **思路：**借用一个辅助栈。遍历压栈顺序，将元素放入辅助栈，然后判断栈顶元素与弹出顺序第一个元素相等，若相等则出栈并将弹出顺序向后移动一位，直到不相等；最后若辅助栈不为空，说明弹出序列不是该栈的弹出顺序

```java
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA.length == 0 || popA.length == 0)
            return false;
        Stack<Integer> s = new Stack<Integer>();//辅助栈
        int popIndex = 0;//用于标识弹出序列的位置
        for(int i = 0; i< pushA.length;i++){
            s.push(pushA[i]);
            //如果栈不为空且栈顶元素等于弹出序列，则出栈并将弹出序列向后移动一位
            while(!s.empty() &&s.peek() == popA[popIndex]){
                s.pop();
                popIndex++;
            }
        }
        return s.empty();
    }
}
```



##### 【3】两个队列实现栈【可以用abcde测试数据梳理思路】

> - **思路：**就是进栈的时候都进到左边队列当中，出栈的话各种判空处理【入栈看1，出栈看2】
>   - 进栈操作简单：全部进入一队列，
>   - 出栈：
>     - 二为空的话：一队列全部出队到二队，输出最后一个。
>     - 二不为空：
>       - 一为空：二转移到一种，输出最后一个
>       - 一不为空，一转移到二中，输出最后一个
>
> - **复杂度：**入栈O(1)，出栈O(n)

```java
class MyStack {

    List<Integer> queueOne;
    List<Integer> queueTwo;

    /**
     * Initialize your data structure here.
     */
    public MyStack() {
        queueOne = new LinkedList<>();
        queueTwo = new LinkedList<>();
    }

    /**
     * Push element x onto stack.
     */
    public void push(int x) {
        //一直入一队
        queueOne.add(x);
    }

    /**
     * Removes the element on top of the stack and returns that element.
     */
    public int pop() {
        //两队皆空
        if (queueOne.isEmpty() && queueTwo.isEmpty()) {
            return -1;
        }
        //二队空就把一队转移到二队
        if (queueTwo.isEmpty()) {
            while (queueOne.size() > 1) {
                int temp = queueOne.remove(0);
                queueTwo.add(temp);
            }
            return queueOne.remove(0);
        } else {//二队不空前提下看一队是否空
            //一队不空，还是将一队转移到二队，输出最后一个
            if (!queueOne.isEmpty()) {
                while (queueOne.size() > 1) {
                    int temp = queueOne.remove(0);
                    queueTwo.add(temp);
                }
                return queueOne.remove(0);
            } else {//一队空，所以就将二队转移到一队
                while (queueTwo.size() > 1) {
                    int temp = queueTwo.remove(0);
                    queueOne.add(temp);
                }
                return queueTwo.remove(0);
            }
        }
    }

    /**
     * Get the top element.
     */
    public int top() {
        if (queueOne.isEmpty() && queueTwo.isEmpty()) {
            return -1;
        }
        if (queueTwo.isEmpty()) {
            while (queueOne.size() > 1) {
                int temp = queueOne.remove(0);
                queueTwo.add(temp);
            }
            int temp=queueOne.get(0);
            queueOne.remove(0);
            queueTwo.add(temp);
            return temp;
        } else {
            if (!queueOne.isEmpty()) {
                while (queueOne.size() > 1) {
                    int temp = queueOne.remove(0);
                    queueTwo.add(temp);
                }
                int temp=queueOne.get(0);
                queueOne.remove(0);
                queueTwo.add(temp);
                return temp;
            } else {
                while (queueTwo.size() > 1) {
                    int temp = queueTwo.remove(0);
                    queueOne.add(temp);
                }
                int temp=queueTwo.get(0);
                queueTwo.remove(0);
                queueOne.add(temp);
                return temp;
            }
        }
    }

    /**
     * Returns whether the stack is empty.
     */
    public boolean empty() {
        return queueOne.isEmpty() && queueTwo.isEmpty();
    }
```



##### 【4】两个栈实现队列

> - **题目：**两个栈实现队列
>
> - **思路：**就是入队的时候都进到左边栈当中，出队的话各种判空处理
>
>   - 进队操作简单：全部进入一栈
>
>   - 出队：
>     - 二为空的话：一栈全部出弹出到二栈，输出最后一个。
>     - 二不为空：不用管一什么情况，直接二弹出栈顶
>
> - **复杂度：**入队O（1），出队最坏情况O（n）

```java
//仅有关键代码
  public int pop() {
        if (stack1.empty() && stack2.empty()) {
            throw new EmptyStackException();
        }
        if (stack2.size() == 0) {
            while (!stack1.empty()) {
                int temp = stack1.pop();
                stack2.push(temp);
            }
        }
        return stack2.pop();
    }
```



#### 动态规划

##### 【1】跳台阶

> - **题目：**一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
> - **思路：**对于第n个台阶来说，只能从n-1或n-2的台阶跳上来，因此跳到n阶的跳法=跳到n-1阶的方案+跳到n-2阶的方案，即F(n) = F(n-1) + F(n-2)，是个斐波拉契数序列，比如跳到第十节台阶可以从第9节或者第8节跳上来，这个时候F(10)=F(9)+F(8)

```java
//递归法
public class Solution {
    public int JumpFloor(int target) {
        if (target <= 2) {
            return target;
        } else {
            return  JumpFloor(target-1)+JumpFloor(target-2);
        }
    }
}
//迭代法
public class Solution {
    public int JumpFloor(int target) {
        if (target <= 2) {
            return target;
        } 
        int f1=1;
        int f2=2;
        int f=0;
        for(int i=3;i<=target;i++){
            f=f1+f2;
            f1=f2;
            f2=f;
        }
        return f;
    }
}
```



##### 【2】变态跳台阶

> 就是每次不只是可以跳1或者2节台阶，可以跳n节
>
> 假设跳上第n个台阶有f(n)种方法，则f(1)=1,f(2)=2,f(3)=4,f(4)=8,我们隐约感觉到f(n)=2^(n-1)。但是需要证明下，同样根据我们根据上篇文章中跳台阶的思路，可以得到**f(n)=f(n-1)+f(n-2)+....+f(1)+1,而f(n-1)=f(n-2)+....+f(1)+1**,两个式子相减，得到f(n) = 2f(n-1),很明显可以得到**f(n)=2^(n-1)**

```java
//循环
public static  int JumpFloorII(int target) {
     	if (target==0){
            return 0;
        }
    
        int result=1;
        for (int i=0;i<target-1;i++){
            result=result*2;
        }
    	//其实就是下面一行代码
   		//result= (int) Math.pow(2,target-1);
        return result;
    }
//递归
//f(n) = 2*f(n-1)*/
    public int JumpFloorII(int target) {
        if(target<=0){
            return 0;
        }else if(target==1){
            return 1;
        }else{
            return 2*JumpFloorII(target-1);
        }
    }
```



##### 【3】剪绳子

> - **题目：**
>   - 给你一根长度为n的绳子，请把绳子剪成m段（m , n ）都是正整数，（n>1&m>1）
>   - 每段绳子的长度为k[0],k[1],k[2],...,k[m]。请问k[0]*k[1]*k[2]*...*k[m]的最大值。
>   - 例如绳子是长度为8，我们把它剪成的长度分别为2,3,3的三段，此时得到的最大的乘积是18
> - **思路：**
>   - 动态规划：先从最低处开始计算乘积并将每个数可以剪切后得到的乘积最大值进行存储。当计算后面的值的时候利用已经存储好的最大值，计算所有可能的结果并保留最大的。
>   - 贪婪算法：这次我们来换一个思路，我们可以知道当(n>=5)时，存在(2*(n-2))>n和(3*(n-3))>n。
>     又因为当n>=5 时有 3*(n-3)>=2*(n-2)，所以我们应该**尽量剪出3来得到最大值**。
>     **当长度为4时，2*2最大**。
> - **复杂度：**
>   - 动态规划：时间：O（n^2），空间O（n）
>   - 贪婪算法：时间：O（1），空间O（1）

```java
//动态规划
public static int getMaxResult(int length) {
        
        int[] res = null ;
        int max = 0 ;
        if(length < 2 ) {
            return 0 ;
        }
        if(length == 2) {
            return 1 ;
        }
        if(length == 3) {
            return 2 ;
        }
        
    	//res的值是砍出来的每一段的长度，比如4砍出来1，3或者2，2
        res = new int[length+1] ;
        res[0] = 0 ;
        res[1] = 1 ;
        res[2] = 2 ;
        res[3] = 3 ;
        //此处是关键，
    	//res[4] = 4; -》[1，3] [2，2]
    	//res[5] = 6; -》[1，4] [2，3]
        for(int i = 4 ; i <= length ; i ++) {
            max = 0 ;
            //这个循环就是两端相乘，往中间缩进
            for(int j = 1 ; j <= i/2 ; j++) {
                int r = res[j] * res[i-j] ;
                if(max < r) {
                    max = r ;
                    res[i] =max ;
                }
            }
        }
        max = res[length] ;
        return max ;
    }

//贪婪算法
public static int getMaxResult1 (int length) {
        
        if(length < 2 ) {
            return 0 ;
        }
        if(length == 2) {
            return 1 ;
        }
        if(length == 3) {
            return 2 ;
        }
        
        int timesOf3 = length/3 ;
    	//如果能有一个四
        if(length - timesOf3*3 == 1) {
            //提取出一个四，3的段数减一
            timesOf3 -= 1 ;
        }
        
    	//0个或者两个
        int timesOf2 = (length - timesOf3*3)/2 ;
        //pow() 函数用来求 x 的 y 次幂(次方),
        return (int) (Math.pow(3, timesOf3) * Math.pow(2, timesOf2)) ;
    }
```



### 2、数组

#### 【1】快速从一组无序数中找到第k大的数（或前k个大的数）

> 思路：利用快排思想，直至找到一个排在第k位置的枢轴，因为左边所有数据都比它大，右边都比它小。

```java
public class QuickSort {    
    public int partition(int[] arr,int low,int high){
        int temp=arr[low];
        while(low<high){
            while(arr[high]<=temp&&high>low){
                high--;
            }
            arr[low]=arr[high];
            while(arr[low]>=temp&&low<high){
                low++;
            }
            arr[high]=arr[low];
        }
        arr[high]=temp;
        return high;        
    }
    public void findK(int k,int[] arr,int low,int high){
        int temp=partition(arr,low,high);
        if(temp==k-1){
            System.out.print("第"+k+"大的数是："+arr[temp]);
        }else if(temp>k-1){
            findK(k,arr,low,temp-1);            
        }else{
            findK(k,arr,temp+1,high);
        }
    }
}
```



#### 【2】二维数组查找

> - 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数
> - 思路：从左下角开始查找，当比关键字小时右移，反之上移

```java
public class Solution {
    //右上角开始找
    private boolean findInArrayFromRightTop(int[][] arr, int rows, int columns, int number) {

        if (arr != null && rows > 0 && columns > 0) {
            int currntRow = 0;
            int currentColumn = columns - 1;
            while (currntRow < rows && currentColumn >= 0) {//往左下方缩小，所以控制范围
                if (arr[currntRow][currentColumn] == number) {
                    System.out.println("该数坐标:"+currntRow+"，"+currentColumn);
                    return true;
                } else if (arr[currntRow][currentColumn] < number) {
                    currntRow++;
                } else {
                    currentColumn--;
                }
            }
        }
        return false;
    }
    
	//左下角开始找
    private boolean findInArrayFromLeftBottom(int[][] arr, int rows, int columns, int number) {

        if (arr != null && rows > 0 && columns > 0) {
            int currntRow = rows - 1;
            int currentColumn = 0;
            while (currntRow >= 0 && currentColumn < columns) {//往右上方缩小，所以控制范围
                if (arr[currntRow][currentColumn] == number) {
                    System.out.println("该数坐标:"+currntRow+"，"+currentColumn);
                    return true;
                } else if (arr[currntRow][currentColumn] < number) {
                    currentColumn++;
                } else {
                    currntRow--;
                }
            }
        }
        return false;
    }
}
```



#### 【3】数组中出现次数超过一半的数字

> - 题目：找出数组中有出现的次数超过数组长度的一半的数字，如果不存在则输出0。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}，由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。
> - 思路：在遍历数组时保存两个值，一是数组中一个数字，一是次数；遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则减1；若次数为0，则保存下一个数字，并将次数置为1；遍历结束后，所保存的数字即为所求；然后再判断它是否符合条件即可。

```java
public class Main {
	 /**
     * 依据数组结构特性，超过一半。。。。 
     * 遍历数组，如果下一个数字和之前保存的数字相同则次数+1，不同则-1
     * 如果次数为0，则需要保存下一个数字，并设置次数为1
     * 最后一次把次数设置为1的数字就是结果
     */
    public static int moreThanHalfNum(int[] numbers) {
        if (numbers == null || numbers.length < 1) {
            return 0;
        }

        int result = numbers[0];
        int times = 1;
        //首先找出出现最多的数字，然后再检验是否超过半数
        for (int i = 1; i < numbers.length; i++) {
            //注意次数减为0的情况
            if (times == 0) {
                result = numbers[i];
                times = 1;
            } else if (result == numbers[i]) {
                times++;
            } else {
                times--;
            }
        }

        //检验是否超半数
        times = 0;
        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i] == result) {
                times++;
            }
        }
        if (times * 2 <= numbers.length) {
            return 0;
        }

        return result;
    }
}
```



#### 【4】顺时针打印矩阵

> - 题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如如果输入如下4 X 4矩阵， 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10
>
>   1    2   3   4
>   5    6   7   8
>   9   10 11 12
>   13 14 15 16
>
> - 思路：用左上和右下的坐标定位出一次要旋转打印的数据，一次旋转打印结束后，往对角分别前进和后退一个单位。注意单行或者单列的情况。

```java
public static void main(String[] args) {
        //1  2  3   4 5
        //6  7  8   9 10
        //11 12 13 14 15
        //16 17 18 19 20
        //21 22 23 24 25
        int count = 1;
        int[][] matrix = new int[5][5];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                matrix[i][j] = count;
                count++;
            }
        }
        Solution.printMatrix(matrix, 5, 5);
    }

class Solution {
    public static void printMatrix(int[][] matrix, int columns, int rows) {
        if (matrix == null || columns <= 0 || rows <= 0) {
            return;
        }

        //start可以理解为对角线偏移量
        int start = 0;
        //注意while循环的控制条件
        while (columns > 2 * start && rows > 2 * start) {
            printCircle(matrix, columns, rows, start);
            start++;
            System.out.println("");
        }
    }

    //for + 3if模型
    //if里的判断条件在极端的时候适用，比如横线，竖线，两行横线这种情况
    private static void printCircle(int[][] matrix, int columns, int rows, int start) {
        //结束标志
        int endX = columns - 1 - start;
        int endY = rows - 1 - start;
        //从左到右打印第一行
        for (int i = start; i <= endX; i++) {
            System.out.print(matrix[start][i] + " ");
        }
        //从上到下打印第一列
        if (start < endY) {
            for (int i = start + 1; i <= endY; i++) {
                System.out.print(matrix[i][endX] + " ");
            }
        }
        //从右到左打印第二行
        if (start < endX && start < endY) {
            for (int i = endX - 1; i >= start; i--) {
                System.out.print(matrix[endY][i] + " ");
            }
        }
        //从下到上打印第二列
        if (start < endX && start < endY - 1) {
            for (int i = endY - 1; i >= start + 1; i--) {
                System.out.print(matrix[i][start] + " ");
            }
        }
        //打印结果
        //1 2 3 4 5 10 15 20 25 24 23 22 21 16 11 6
        //7 8 9 14 19 18 17 12
        //13
    }
}
```



#### 【5】两数之和

> - **题目：**给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。
> - **思路：**事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。
> - **复杂度：**时间：O（n），空间O（n）

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException("No two sum solution");
}
```



#### 【6】删除排序数组中的重复项

> - **题目：**删除排序数组中的重复项，返回数组的长度
> - **思路：**利用快慢指针法
> - **复杂度：**时间：O（n），空间O（1）

```java
public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;
    int i = 0;
    //开始条件 i=0；j=1；
    for (int j = 1; j < nums.length; j++) {
        //之前一直都是相等的，突然遇到个不是相等的
        //如果二者不等，说明需要前移数字了
        if (nums[j] != nums[i]) {
            //注意先i++，再移动数字
            i++;
            nums[i] = nums[j];
        }
    }
    //返回值是数组长度
    return i + 1;
}
```



#### 【7】买股票的最佳时机

> - **题目：**给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票
>
> - **示例 1:**
>
>   ```java
>   输入: [7,1,5,3,6,4]
>   输出: 5
>   解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>        注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
>   ```
>
>   **示例 2:**
>
>   ```java
>   输入: [7,6,4,3,1]
>   输出: 0
>   解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
>   ```
>
> - **思路：**
>
>   - 暴力法：不推荐
>   - 一次遍历：加入将给定的数组绘制成折线图，使我们感兴趣的点是上图中的峰和谷。**我们需要找到最小的谷之后的最大的峰。** 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）
>
> - **复杂度：**时间：O（n），空间O（1）

```java
public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            //遇到最小值那么就替换最小值
            if (prices[i] < minprice)
                minprice = prices[i];
            //如果是更低峰谷则替换峰谷，否则计算利润
            else if (prices[i] - minprice > maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
    }
}
```



#### 【8】买股票的最佳时机II

> - **题目：**
>
>   - > 区别于1就是可以多次买入一只股票
>
>     给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。
>
>     设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>
>     **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> - **示例 1:**
>
>   ```java
>   输入: [7,1,5,3,6,4]
>   输出: 7
>   解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>        随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
>   ```
>
>   **示例 2:**
>
>   ```java
>   输入: [1,2,3,4,5]
>   输出: 4
>   解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>        注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
>        因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
>   ```
>
>   **示例 3:**
>
>   ```java
>   输入: [7,6,4,3,1]
>   输出: 0
>   解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
>   ```
>
> - **思路：**
>
>   - 暴力法：不推荐
>   - 简单的一次遍历：每两个点计算折线图高度差想加
>
> - **复杂度：**时间：O（n），空间O（1）

```java
//简单的一次遍历
class Solution {
    public int maxProfit(int[] prices) {
        int maxprofit = 0;
        for (int i = 1; i < prices.length; i++) {
            //比较相邻两个点的高度差
            if (prices[i] > prices[i - 1])
                //累加利润
                maxprofit += prices[i] - prices[i - 1];
        }
        return maxprofit;
    }
}
```



#### 【9】排序数组数字出现的次数

> 记住两个关键的判断条件
>
> - //判断是不是第一个K，前一个不等于K，就是第一个K
>   if (middleIndex > 0 && array[middleIndex - 1] != k || middleIndex == 0) {
> - //判断是不是最后一个K，后一个不等于K，就是最后一个K
>   if (middleIndex < array.length - 1 && array[middleIndex + 1] != k || middleIndex == array.length - 1)

```java
public int GetNumberOfK(int [] array , int k) {
      int num = 0;
        if (array != null && array.length > 0) {
            int firstKIndex = getFirstK(array, k, 0, array.length - 1);
            int lastKIndex = getLastK(array, k, 0, array.length - 1);
            if (firstKIndex > -1 && lastKIndex > -1)
                num = lastKIndex - firstKIndex + 1;
        }
        return num;
    }

    /*
    * 找到第一个出现的数字的下标
    */
    public  int getFirstK(int[] array, int k, int start, int end) {
        if (start > end)
            return -1;
        int middleIndex = start + (end - start) / 2;
        int middleData = array[middleIndex];
        //先判断中间的值是否等于k
        if (middleData == k) {
        //判断是不是第一个K，前一个不等于K，就是第一个K
            if (middleIndex > 0 && array[middleIndex - 1] != k || middleIndex == 0) {
                return middleIndex;
            } else
                end = middleIndex - 1;
        } else if (middleData > k) {
            end = middleIndex - 1;
        } else
            start = middleIndex + 1;
        return getFirstK(array, k, start, end);
    }

     /*
    * 找到最后一个出现的数字的下标
    */
    public  int getLastK(int array[], int k, int start, int end) {
        if (start > end) {
            return -1;
        }
        int middleIndex = (start + end) / 2;
        int middleData = array[middleIndex];
        if (middleData == k) {
         //判断是不是最后一个K，后一个不等于K，就是最后一个K
            if (middleIndex < array.length - 1 && array[middleIndex + 1] != k || middleIndex == array.length - 1)
                return middleIndex;
            else
                start = middleIndex + 1;
        } else if (middleData < k) {
            start = middleIndex + 1;
        } else
            end = middleIndex - 1;
       return getLastK(array, k, start, end);
    }
```



### 3、字符串

- [minmin的总结](https://www.jianshu.com/p/9648e8dd5bdb)

#### 【1】最长子串

> - 题目：从字符串中找出一个最长的不包含重复数字的子字符串的长度。例如在字符串中”arabcacfr”，最长非重复子字符串为“rabc”或”acfr”，长度为4
> - 思路：使用动态规划。先用长度为26的数组positions来存储当前字符上次出现的位置；再定义字符串长度的数组lines表示以当前字母为结尾的最长不含重复字符的子字符串的长度。依次遍历字符串中的字符：
>   - 若当前字符是第一次出现，说明可以直接添加到前一个非重复子字符串，因此lines[i]=lines[i-1]+1；
>   - 若当前字符非第一次出现，需计算当前字符与它上次出现位置之间的距离d：
>     - 若d大于lines[i-1]，说明前一个非重复子字符串中没有包含当前字符，可以添加当前字符到前一个非重复子字符串中，因此lines[i]=lines[i-1]+1；
>     - 若d小于或等于f(i-1)，说明如果加入当前字符会存在重复字符串，需要把上次出现的字符截开，因此lines[i] = d

```java
private int findLongestSubstringLength(String string){
        if (string == null || string.equals("")) {
            return 0;
        }
        int maxLength = 0;//最长不重复子字符串的长度
        int[] positions = new int[26];//存储当前字符上次出现的位置，-1表示没有出现过
        for (int i = 0; i < positions.length; i++){
            positions[i] = -1; 
        }
        int[] lines = new int[string.length()];//存储以当前字符为尾的最长不重复子字符串的长度
        lines[0]=1;
        positions[string.charAt(0) - 'a']=0;
        for (int i = 1; i < string.length(); i++){
            int prePosition = positions[string.charAt(i) - 'a'];
            if(prePosition>=0){//当前字符非第一次出现
                if((i-prePosition)>lines[i-1]){
                    lines[i]=lines[i-1]+1;
                }else{
                    lines[i]=i-prePosition;//若加入当前字符会出现重复，需要截断
                }
            }else{//当前字符是第一次出现
                lines[i]=lines[i-1]+1;
            }
            positions[string.charAt(i) - 'a'] = i;
            if(lines[i]>maxLength){
                maxLength=lines[i];
            }
        }
        return maxLength;
}
```



#### 【2】替换空格

```java
//replace函数
public static String replaceBlank(StringBuffer sb){
	for (int i = 0; i < sb.length(); i++) {
		char ch1 = sb.charAt(i);
		if(ch1 == ' '){
			sb.replace(i, i+1, "%20");
		}
	}
	return sb.toString();
}
//replaceAll函数
public static String replaceBlank2(String str){
	String str1 = str.replaceAll(" ", "%20");
	return str1;
}
```



#### 【3】第一次只出现一次的字符

> - **题目：**在字符串中找出第一个只出现一次的字符。如输入"abaccdeff"，则输出'b'.
> - **思路：**利用哈希表存储已经遍历过的字符串
> - **复杂度：**时间：O（n），空间O（n）

```java
public class Main {

    public static void main(String[] args) {
        String template = "wangjinmingchengkunfupengbigepangxianyuwangcheng";
        System.out.println(firstNotRepeatingChar(template));
    }

    public static Character firstNotRepeatingChar(String template) {
        if (template == null) {
            return null;
        }

        //注意是LinkedhashMap，要么遍历检验的时候遍历array不要遍历keySet
        //LinkedHashMap是根据插入顺序来保证有序的
        LinkedHashMap<Character, Integer> map = new LinkedHashMap<>();
        char[] array = template.toCharArray();
        for (char key : array) {
            if (map.containsKey(key)) {
                map.put(key, map.get(key) + 1);
            } else {
                map.put(key, 1);
            }
        }
        for (char key : map.keySet()) {
            if (map.get(key) == 1) {
                return key;
            }
        }
        return null;
    }
}
```



#### 【4】只出现一次的数字I、II、III

```java
//题目1------一个一次[2次中挑]
//思路：一直亦或[1^1=0 0^0=0 1^0=1 0^1=1 两者相等为0,不等为1]
给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
class Solution {
    public int singleNumber(int[] nums) {
        int len = nums.length;
        int result=0;
       for(int i=0;i<len;i++){
           result ^=nums[i];
       } 
        return result;
    }
}

//题目2-----一个一次[3次中挑]
给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
//思路：记录每位出现1的次数，如果能被3整除说明唯一存在的数在这一位上为1.
class Solution {
      public int singleNumber(int[] nums) {
        // 对每一位单独统计出现1的次数, 
        // 如果出现的次数不能整除3说明唯一存在的数在这一位上为1, 时间复杂度O(32N)
        int ret = 0;
        for(int i = 0; i < 32; ++i) {
            int bitnums = 0;
            int bit = 1 << i;
            for(int num : nums) {
                if((num&bit) != 0)
                    bitnums++;
            }
            if(bitnums % 3 != 0)
            	//改变result的位
                ret |= bit;
        }
        return ret;
    }
}

//题目3-----两个一次[2次中挑]
给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。
你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
//思路：
class Solution {
    public static int[] singleNumber2(int[] nums) {
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            result ^= nums[i];
        }
        List<Integer> listOne = new ArrayList<>();
        List<Integer> listTwo = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
        }
        int[] ck = new int[0];
        return ck;
    }

    public static int[] singleNumber(int[] nums) {
        if (nums == null || nums.length == 0) return null;

        //得到第一次循环后端亦或结果
        int ck = 0;
        for (int num : nums) {
            ck ^= num;
        }

        List<Integer> listOne = new ArrayList<>();
        List<Integer> listTwo = new ArrayList<>();

        //分组条件
        int f = 1;
        while ((f & ck) != f) {
            f <<= 1;
        }

        //分组
        for (int num : nums) {
            if ((f & num) == f) {
                listOne.add(num);
            } else {
                listTwo.add(num);
            }
        }

        int[] resultOne = new int[listOne.size()];
        int[] resultTwo = new int[listTwo.size()];

        for (int i = 0; i < listOne.size(); i++) {
            resultOne[i] = listOne.get(i);
        }

        for (int i = 0; i < listTwo.size(); i++) {
            resultTwo[i] = listTwo.get(i);
        }

        //对两个小分组进行亦或
        for (int i = 1; i < listOne.size(); i++) {
            resultOne[0] ^= resultOne[i];
        }
        for (int i = 1; i < resultTwo.length; i++) {
            resultTwo[0] ^= resultTwo[i];
        }

        //返回两个小组亦或后的结果
        return new int[]{resultTwo[0], resultOne[0]};
    }
}
```





### 4、链表

#### 【1】从尾到头打印链表

> - **题目：**输入一链表的头结点，从尾到头输出链表，注意是尾到头
> - **思路：**两种解法，递归和利用辅助栈
> - **复杂度：**
>   - 辅助栈：时间：O（n），空间O（n）
>   - 递归：时间：O（n），空间O（1），链表过长容易栈溢出

```java
//辅助栈
public class Main {
    Stack<Integer> stack = new Stack<>();

    private void showListFromTailToHead(ListNode head) {
        if (head == null) {
            System.out.println("链表为空");
        } else {
            ListNode tempNode = head;
            while (tempNode != null) {
                stack.push(tempNode.val);
                tempNode = tempNode.next;
            }
            while (!stack.empty()) {
                System.out.print(stack.pop() + " -> ");
            }
            stack = null;
        }
    }
}
//递归
private void showListFromTailToHead(ListNode head) {
        if (head == null) {
            System.out.println("链表为空");
        } else {
            showListFromTailToHead(head.next);
            System.out.print(head.val + " - > ");
        }
    }
```



#### 【2】翻转链表

> - **题目**：翻转链表
> - **思路：**三个节点：前、中、后
> - **复杂度：**时间：O（n），空间O（1）

```java
private ListNode reverseList(ListNode head) {
        //翻转时需要储存前中后三个节点的引用以及返回节点的
        ListNode resultHead = null;
        ListNode currnetNode = head;
        ListNode preNode = null;
        ListNode nextNode = null;
        while (currnetNode != null) {
            nextNode = currnetNode.next;
            if (nextNode == null) {//找到链表尾部
                resultHead = currnetNode;
            }
            currnetNode.next = preNode;//将当前节点next指向头一个节点
            preNode = currnetNode;//当前节点做头
            currnetNode = nextNode;//下一个节点做当前节点
        }
        return resultHead;
    }
```



#### 【3】判断链表有环

> - 题目：如何判断一个链有环，**请找出该链表的环的入口结点**，否则输出null
> - 思路：用p1、p2指向链表头部，然后p1每次走一步、p2每次走两步；显然，当p1和p2第一次相遇时，p2正好比p1多走了一个环；设p2此时走了2x步，p1走了x步，则环长=2x-x=x，因此p1和p2相遇点正好是环的入口点，只要找到p1==p2时的节点即可

```java
class Solution {
    public static LinkNode entryNodeOfLoop(LinkNode head) {
        //判断链表长度大于等于3
        if (head == null || head.next == null || head.next.next == null) {
            return null;
        }
        LinkNode fast = head.next.next;
        LinkNode slow = head.next;
        //找到相遇点，将快节点置为头，再次相遇即为头
        while (fast != slow) {
            //记住if条件
            if (fast.next!=null && fast.next.next != null ) {
                fast = fast.next.next;
                slow = slow.next;
            } else {
                return null;
            }
        }
        //快指针变为头，一次走一步
        fast = head;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```



#### 【4】如何判断两条链表交叉

> - **题目：**编写一个程序，找到两个单链表相交的起始节点
> - **思路：**如果两个单向链表有公共的结点，也就是说两个链表从某一结点开始，它们的m_pNext都指向同一个结点。但由于是单向链表的结点，每个结点只有一个m_pNext，因此从第一个公共结点开始，之后它们所有结点都是重合的，不可能再出现分叉。所以，两个有公共结点而部分重合的链表，拓扑形状看起来像一个Y，而不可能像X。
>   - 暴力循环复杂度O(m*n)
>   - 利用两个辅助栈，空间换时间O（m+n）
>   - 先遍历两个链表到尾部，得知链表的长度m和n，然后比较谁长，长的在下一次遍历的时候就多走几步，然后大家走到同一个位置，然后一起开始遍历找到相等的节点
>   - 
> - **复杂度：**O（m+n）

```java
//解法3
public class Main {

    public static LinkNode findFirstCommonNode(LinkNode headOne, LinkNode headTwo) {
        if (headOne == null || headTwo == null) {
            return null;
        }

        LinkNode result = null;
        LinkNode currentOne = headOne;
        LinkNode currentTwo = headTwo;
        int lengthOne = getLinkedNodeLength(headOne);
        int lengthTwo = getLinkedNodeLength(headTwo);
        boolean isOneBigger = (lengthOne - lengthTwo) > 0 ? true : false;
        int diffValue = isOneBigger ? lengthOne - lengthTwo : lengthTwo - lengthOne;
        //如果第一个链表更长
        if (isOneBigger) {
            while (diffValue > 0) {
                currentOne = currentOne.next;
                diffValue--;
            }
        } else {
            while (diffValue > 0) {
                currentTwo = currentTwo.next;
                diffValue--;
            }
        }
        while (currentOne != null) {
            if (currentOne.data != currentTwo.data) {
                currentOne = currentOne.next;
                currentTwo = currentTwo.next;
            } else {
                result = currentOne;
                break;
            }
        }
        return result;
    }

    /**
     * 获取链表长度
     */
    public static int getLinkedNodeLength(LinkNode head) {
        int result = 0;
        LinkNode current;
        current = head;
        while (current != null) {
            current = current.next;
            result++;
        }
        return result;
    }
}
```

```java
//解法4
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        /**
        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)
        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度
        **/
        if(headA == null || headB == null) return null;
        ListNode pA = headA, pB = headB;
        // 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null
        while(pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
```



#### 【5】删除排序链表重复节点

> - 题目：在一个排好序的链表中存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，并返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5。
> - 思路：

```java
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
    ListNode current = head;
    while (current != null && current.next != null) {
        if (current.next.val == current.val) {
            //如果值相等就指向下下个
            current.next = current.next.next;
        } else {
            //否则current往后移动
            current = current.next;
        }
    }
    return head;
	}
}
```



#### 【6】倒数第k个节点[找到与删除]

> - 题目：输入一个链表，输出该链表中倒数第k个结点
> - 思路：用p1、p2指向链表头部，先让p1走(k-1)步到达第k个节点，此时p1和p2相隔k个节点；然后p1、p2同时往后移动，当p1到达链尾时，p2所在位置正是倒数第k个节点

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    //防止个数为1的时候的空指针异常
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode first = dummy;
    ListNode second = dummy;
    // 注意i< = n+1
    for (int i = 1; i <= n + 1; i++) {
        first = first.next;
    }
    // 注意是first！=null
    while (first != null) {
        first = first.next;
        second = second.next;
    }
    second.next = second.next.next;
    return dummy.next;
}
```



#### 【7】合并有序链表

> - 题目：输入两个单调递增的链表，输出两个链表合成后的链表，并保证满足单调不减规则。
> - 思路：每次都取俩链表中最靠前的俩元素中的更小元素到重组链表中，被取走元素的旧链表后移一个元素继续进行“车轮战”；注意如果只剩一条未结束链表要记得全部插入到重组链表的最后

```java
//方法1:非递归
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        //新建一个头节点，用来存合并的链表
        ListNode head=new ListNode(-1);
        head.next=null;
        ListNode root=head;
        while(list1!=null&&list2!=null){
            if(list1.val<list2.val){
                head.next=list1;
                head=list1;
                list1=list1.next;
            }else{
                head.next=list2;
                head=list2;
                list2=list2.next;
            }
        }
        //把未结束的链表连接到合并后的链表尾部
        if(list1!=null){
            head.next=list1;
        }
        if(list2!=null){
            head.next=list2;
        }
        return root.next; 
    }
}
//方法2:递归
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode result;
        if (l1 == null && l2 == null) {
            return null;
        } else if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        }
        if (l1.val < l2.val) {
            result = l1;
            result.next = mergeTwoLists(l1.next, l2);
        } else {
            result = l2;
            result.next = mergeTwoLists(l1, l2.next);
        }
        return result;
    }
}
```



#### 【8】链表相加

> - **题目：**给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。
>
>   如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
>
>   您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> - **示例：**
>
>   ```java
>   输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
>   输出：7 -> 0 -> 8
>   原因：342 + 465 = 807
>   ```
>
> - **思路：**注意最后的进位，如果还有进位还需要new一个节点
>
> - **复杂度：**时间：O（n），空间O（n）

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    //结果表的表头
    ListNode dummyHead = new ListNode(0);
    ListNode p = l1, q = l2, curr = dummyHead;
    //进位
    int carry = 0;
    //循环跳出条件，二者都为空
    while (p != null || q != null) {
        int x = (p != null) ? p.val : 0;
        int y = (q != null) ? q.val : 0;
        //和
        int sum = carry + x + y;
        //进位
        carry = sum / 10;
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
        //注意空指针异常
        if (p != null) p = p.next;
        if (q != null) q = q.next;
    }
    if (carry > 0) {
        curr.next = new ListNode(carry);
    }
    return dummyHead.next;
}
```



#### 【9】链表相加II

```java
//借住辅助栈然后套路如上
//再开一个栈用于存放链表
```



#### 【10】回文链表

> - **题目：**
> - **思路：**
> - **复杂度：**时间：O（），空间O（）

```java
//借住辅助链表
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<ListNode> linkNodes = new LinkedList<>();

        if (head == null || head.next == null)
            return true;
        ListNode fast = head;
        ListNode slow = head;
        //记住判断关键语句
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        //入队
        slow = slow.next;
        while (slow != null) {
            linkNodes.add(new ListNode(slow.val));
            slow = slow.next;
        }
        //判断
        for (int i = linkNodes.size()-1; i >=0 ; i--) {
            if (linkNodes.get(i).val!=head.val){
                return false;
            }
            head=head.next;
        }
        return true;
    }
}

//翻转后半段链表
class Solution {
    public boolean isPalindrome(LinkNode head) {
        if (head == null || head.next == null)
            return true;
        LinkNode fast = head;
        LinkNode slow = head;
        //记住判断关键语句
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        //翻转链表
        LinkNode reverseHead = reverseList(slow.next);

        while (head != null && reverseHead != null) {
            if (head.data != reverseHead.data)
                return false;
            head = head.next;
            reverseHead = reverseHead.next;
        }
        return true;
    }
	
   //翻转链表
   private ListNode reverseList(ListNode head) {
        //翻转时需要储存前中后三个节点的引用以及返回节点的
        ListNode resultHead = null;
        ListNode currnetNode = head;
        ListNode preNode = null;
        ListNode nextNode = null;
        while (currnetNode != null) {
            nextNode = currnetNode.next;
            if (nextNode == null) {//找到链表尾部
                resultHead = currnetNode;
            }
            currnetNode.next = preNode;//将当前节点next指向头一个节点
            preNode = currnetNode;//当前节点做头
            currnetNode = nextNode;//下一个节点做当前节点
        }
        return resultHead;
    }
}
```



#### 【11】圆圈中最后剩下的数字

> - **题目：**0， 1，.....， n - 1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字
> - **思路：**
>   - 只要移动m-1次就可以移动到下一个要删除的元素上
>   - 双节点,总保持last.next指向head
> - **复杂度：**时间：O（），空间O（）

```java

```



#### 【12】链表的中间节点

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head, fast = head;
        //注意循环条件
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```



### 5、树

> - 递归结束条件
> - 递归操作-改变root节点
> - 对root和null敏感

#### 【1】二叉树的下一个节点

> - **题目：**给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，**同时包含指向父结点的指针**
>
> - **思路：**【右子树】中序遍历的下一个节点是右子树
>
>   - 有右子树：这种情况比较简单，右节点中序遍历就行，得到返回节点
>
>   - 该节点没有右子树：
>     - 该节点是父节点的左子节点：直接返回父节点
>     - 该节点是父节点的右子节点：
>       - 需要不断的向上移动，直到对应的节点不是父节点的右节点（即左节点），既然他是父节点的左节点，此时将这个节点父节点返回即可
>       - 遍历到了根节点，返回null
>
> - **复杂度**：最坏O（n），单腿二叉树

```java
class Solution {
    public TreeNode getNextNode(TreeNode pNode) {
        if(pNode == null){
            return null;
        }
        //有右子树
        if(pNode.right != null){
            //从右子树根节点一直往左下寻找，最左边最下边的就是要返回的节点
            pNode = pNode.right;
            while(pNode.left != null){
                pNode = pNode.left;
            }
            return pNode;
        }
        //没有右子树，往上找第一个节点是父节点左节点的节点
        while(pNode.parent != null){
            if(pNode.parent.left== pNode){
                return pNode.parent;
            }
            pNode = pNode.parent;
        }
        //没有后续返回null
        return null;
    }
}
```



#### 【2】递归遍历二叉树

```java
	/**
     * 先序遍历
     */
    public void preOrderTraverse(Node head) {
        if (head == null)
            return;
        System.out.print(head.data + " ");
        preOrderTraverse(head.leftChild);
        preOrderTraverse(head.rightChild);
    }

    /**
     * 中序遍历
     */
    public void inOrderTraverse(Node head) {
        if (head == null)
            return;
        inOrderTraverse(head.leftChild);
        System.out.print(head.data + " ");
        inOrderTraverse(head.rightChild);
    }

    /**
     * 后序遍历
     */
    public void postOrderTraverse(Node head) {
        if (head == null)
            return;
        postOrderTraverse(head.leftChild);
        postOrderTraverse(head.rightChild);
        System.out.print(head.data + " ");
    }
```



#### 【3】非递归遍历二叉树

> 关键是条件判断 while while if 模型
>
> -  while (current != null || !stack.empty()) {
>   -  while (current != null) {
>   -  if (!stack.empty()) {
> - 然后再是输出位置
> - 后序：【保存前一个节点】【栈非空开始循环】【如果当前节点左右子节点为空或上一个访问的结点(非空)为当前结点的子节点时，当前结点出栈】
>   -  while (!stack.empty()) {
>   - `if ((current.leftChild == null && current.rightChild == null) ||`
>     `(previous != null && (previous == current.leftChild || previous == current.rightChild))) {`

```java
 	/**
     * 先序非递归
     */
    public void preOrderTraverseByStack(Node head) {
        Stack<Node> stack = new Stack<>();
        Node current = head;
        while (current != null || !stack.empty()) {
            while (current != null) {
                System.out.print(current.data + " ");//先输出
                stack.push(current);
                current = current.leftChild;
            }
            if (!stack.empty()) {
                current = stack.pop();
                current = current.rightChild;
            }
        }
    }

    /**
     * 中序非递归
     */
    public void inOrderTraverseByStack(Node head) {
        Stack<Node> stack = new Stack<>();
        Node current = head;
        while (current != null || !stack.empty()) {
            while (current != null) {
                stack.push(current);
                current = current.leftChild;
            }
            if (!stack.empty()) {
                current = stack.pop();
                System.out.print(current.data + " ");//后输出
                current = current.rightChild;
            }
        }
    }

    /**
     * 后序非递归
     * 
     */
    public void postOrderTraverseByStack(Node head) {
        Stack<Node> stack = new Stack<>();
        Node current;
        //上一个访问
        Node previous = null;
        stack.push(head);
        while (!stack.empty()) {
            //获得头节点值
            current = stack.peek();
            //如果当前节点左右子节点为空或上一个访问的结点为当前结点的子节点时，当前结点出栈
            if ((current.leftChild == null && current.rightChild == null) ||
                    (previous != null && (previous == current.leftChild || previous == current.rightChild))) {
                stack.pop();
                System.out.print(current.data + " ");
            } else {
                //先将右节点入栈，再将左节点入栈
                if (current.rightChild != null) {
                    stack.push(current.rightChild);
                }
                if (current.leftChild != null) {
                    stack.push(current.leftChild);
                }
            }
            previous = current;
        }
    }
```



#### 【4】层序遍历二叉树

> - 题目：实现从上到下按层打印二叉树，同一层结点从左至右输出，每一层输出一行
> - 思路：BFS，队列

```java
	 queue.offer(head);
        while (!queue.isEmpty()) {
            current = queue.poll();
            if (current.leftChild != null) {
                queue.offer(current.leftChild);
            }
            if (current.rightChild != null) {
                queue.offer(current.rightChild);
            }
            System.out.print(current.data + " ");
        }
```

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    if(root == null)
        return new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    while(!queue.isEmpty()){
        int count = queue.size();
        List<Integer> list = new ArrayList<Integer>();
        while(count > 0){
            TreeNode node = queue.poll();
            list.add(node.val);
            if(node.left != null)
                queue.add(node.left);
            if(node.right != null)
                queue.add(node.right);
            count--;
        }
        res.add(list);
    }
    return res;
}
```



#### 【5】从前序与中序遍历序列构造二叉树

> - **题目：**
>
>   前序遍历：左根右 6 4 2 5 3 1 7 
>   中序遍历：左根右 4 2 5 6 1 3 7 
>   后序遍历：左右根 5 2 4 1 7 3 6
>
> - **思路：**根据二叉树的遍历特点进行求解
>
> - **复杂度：**时间：O（n^2），空间O（n^2）从前序与中序遍历序列构造二叉树

```java
    /**
     * 剑指offer提供思路
     * copyOfRange[)左闭右开区间
     */
    public static TreeNode reConstructBinaryTree(int[] pre, int[] in) {
        if (pre.length == 0 || in.length == 0|| pre.length! = in.length) {
            return null;
        }
        TreeNode node = new TreeNode(pre[0]);
        //通过循环找到先根的头元素在中根数组中的位置
        for (int i = 0; i < in.length; i++) {
            if (pre[0] == in[i]) {
                node.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));
                node.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));
            }
        }
        return node;
    }
```



#### 【6】树的子结构

> - **题目：**输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
> - **思路：**先找值相等的点来判断,递归判断值是否相等，控制好判断的时候的边界条件
> - 最坏情况就是遍历整个二叉树

```java
class Solution {

    public static boolean hasSubTree(TreeNode headOne, TreeNode headTwo) {
        if (headOne == null || headTwo == null) {
            return false;
        }
        //先找值相等的点来判断
        boolean result = false;
        if (headOne.data == headTwo.data) {
            result = doesTree1HaveTree2(headOne, headTwo);
        }
        //递归
        if (!result) {
            result = hasSubTree(headOne.leftChild, headTwo);
        }
        //递归
        if (!result) {
            result = hasSubTree(headOne.rightChild, headTwo);
        }
        return result;
    }

    /**
     * 递归判断值是否相等
     */
    private static boolean doesTree1HaveTree2(TreeNode headOne, TreeNode headTwo) {
        //遍历结束
        if (headTwo == null) {
            return true;
        }
        if (headOne == null) {
            return false;
        }
        //值不相等
        if (headOne.data != headTwo.data) {
            return false;
        }
        //关键代码
        return (doesTree1HaveTree2(headOne.leftChild, headTwo.leftChild)
                && doesTree1HaveTree2(headOne.rightChild, headTwo.rightChild));
    }
}
```



#### 【7】对称二叉树

> - **题目：**请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的
> - **思路：**

```java
class Solution {
    boolean isSymmetrical(TreeNode pRoot) {
        return judge(pRoot, pRoot);
    }

    private boolean judge(TreeNode left, TreeNode right) {
        //左右皆空
        if (left == null && right == null) {
            return true;
        }
        //左右有一空
        if (left == null || right == null) {
            return false;
        }
        //左右值是否相等
        if (left.data != right.data)
            return false;
        return judge(left.leftChild, right.rightChild) && judge(left.rightChild, right.leftChild);
    }
}

//迭代解法
public boolean isSymmetric(TreeNode root) {
    Queue<TreeNode> q = new LinkedList<>();
    q.add(root);
    q.add(root);
    while (!q.isEmpty()) {
        TreeNode t1 = q.poll();
        TreeNode t2 = q.poll();
        if (t1 == null && t2 == null) continue;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        //注意节点的加入顺序
        q.add(t1.left);
        q.add(t2.right);
        q.add(t1.right);
        q.add(t2.left);
    }
    return true;
}
```



#### 【8】二叉搜索树与双向链表

```java
class Solution {

    static void tree2list(TreeNode head, LinkedList<TreeNode> list) {
        if (head == null) {
            return;
        }
		
        //向左下递归
        if (head.leftChild != null) {
            tree2list(head.leftChild, list);
        }

        TreeNode last = null;
        if (list.size() > 0) {
            last=list.getLast();
            //链表中最后一个节点即最大节点，
            //该节点的next=头
            last.rightChild = head;
            //头的前节点=链表尾
            head.leftChild = last;
        }
        //将头结点入队
        list.add(head);

        if (head.rightChild != null) {
            tree2list(head.rightChild, list);
        }
    }
}
```



#### 【9】判断二叉搜索树的后序遍历

```java
public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence.length==0)  return false;
        if(sequence.length==1)  return true;
        return judge(sequence, 0, sequence.length-1);
    }
 
    private boolean judge(int[] sequence, int star, int end) {
        if(star>end) {
            return true;
        }
        int i=star;
        while(sequence[i]<sequence[end]) {
            i++;
        }
        for(int j=i;j<end;j++) {
            if(sequence[j]<sequence[end]) {
                return false;
            }
        }
        return judge(sequence,star,i-1)&&judge(sequence,i,end-1);//递归判断左子树与右子树
    }
}
```



#### 【10】二叉树第k大/小节点

> - 题目：给定一棵二叉搜索树，请找出其中的第k小的结点。例如（5，3，7，2，4，6，8）中第三小结点的值为4。
> - 思路：二叉搜索树的中序遍历结果正好是从小到大排序好的，按照中序遍历顺序找第k个节点

```java
//第k小
public class Solution {
    int index = 0; //计数器
    TreeNode KthNode(TreeNode root, int k){
        if(root != null){
            TreeNode node = KthNode(root.left,k);
            if(node != null) return node;//注意需要判断是否为空，否则如果找到符合要求的节点只能返回到上一层，而不能返回到顶层，使得输出结果为null
            index ++;
            if(index == k) return root;
            node = KthNode(root.right,k);
            if(node != null) return node;//理由同上
        }
        return null;
    }
}

//第k大#########
class Solution {

    TreeNode getKthNode(TreeNode head, int k) {
        if (head == null || k == 0) {
            return null;
        }
        return kthNodeCore(head, k);
    }

    private TreeNode kthNodeCore(TreeNode head, int k) {
        TreeNode result = null;
        //中序遍历先到最左下
        if (head.leftChild != null) {
            result = kthNodeCore(head.leftChild, k);
        }
        //到了一个左孩子为空的节点，计数器减一
        if (result == null) {
            if (k == 1) {
                return head;
            }
            k--;
        }
        //head的左孩子为空，右孩子不为空
        if (result == null && head.rightChild != null) {
            result = kthNodeCore(head.rightChild, k);
        }
        return result;
    }

}
```



#### 【11】二叉树深度

```java
class Solution {
    public int treeDepth(TreeNode root) {
        //跳出递归条件
        if (root == null) {
            return 0;
        }

        //对遍历代码稍做修改
        int nLeft = treeDepth(root.leftChild);
        int nRight = treeDepth(root.rightChild);
        return Math.max(nLeft,nRight)+1;
    }
}
```



#### 【12】是否是平衡二叉树

> - 题目：输入一棵二叉树，判断该二叉树是否是平衡二叉树。
> - 思路：从下往上遍历，如果子树是平衡二叉树，则返回子树的高度，反之直接停止遍历，这样至多只对每个结点访问一次

```java
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        return getDepth(root) != -1;
    }
    private int getDepth(TreeNode root) {
        if (root == null) return 0;
        
        int left = getDepth(root.left);
        if (left == -1) return -1;
        int right = getDepth(root.right);
        if (right == -1) return -1;
        
        return Math.abs(left - right) > 1 ? -1 : 1 + Math.max(left, right);
    }
}
```



#### 【13】二叉树的最近公共祖先

> - **题目：**
> - **思路：**
> - **复杂度：**时间：O（），空间O（）

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //根是否已经递归到空
        if (root ==null){
            return null;
        }
        //是否根与p或q相等了，则说明此时root是二者的最近公共祖先
        if (root.val==p.val ||root.val==q.val){//if (root == p || root == q) {
            return root;
        }
        //left和right的意义是
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        //都不为null说明是root
        if (left != null && right != null) {
            return root;
        } else if (left != null) {
            return left;
        } else if (right != null) {
            return right;
        }
        return null;
    }
}
```



#### 【14】二叉搜索树的最近公共祖先

> - **题目：**给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先
> - **思路：**因为二叉搜索树的结构特性，通过p，q与根节点值进行比对变换根节点进行递归
> - **复杂度：**时间：O（），空间O（）

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root ==null){
            return null;
        }
        if(p.val>root.val && q.val>root.val){
            return lowestCommonAncestor(root.right,p,q);
        }
        if(p.val<root.val && q.val<root.val){
            return lowestCommonAncestor(root.left,p,q);
        }
        //注意返回值是root
        return root;
    }
}
```



#### 【15】二叉树展开为链表

> 给定一个二叉树，将它展开为链表
>
> 例如，给定二叉树
>
> ```java
>       1
>      / \
>     2   5
>   / \   \
> 3   4   6
> ```
>
> 将其展开为：
>
> ```java
> 1
>  \
>    2
>      \
>       3
>        \
>         4
>          \
>           5
>            \
>             6
> ```

```java
class Solution {
    public void flatten(TreeNode root) {
        if(root == null){
            return ;
        }
        
        //递归修改左右子树
        flatten(root.left);
        flatten(root.right);
        
        if(root.left != null){
            TreeNode right = root.right;//记录右节点
            root.right = root.left;
            root.left = null;//将左节点置空
            TreeNode node = root.right;//到左节点的最后一个节点
            while(node.right != null){
                node = node.right;
            }
            node.right = right; 
        }
    }
}
```



#### 【16】有序链表转换二叉搜索树

> 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
>
> 本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。
>
> **示例:**
>
> ```java
> 给定的有序链表： [-10, -3, 0, 5, 9],
> 
> 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：
> 
>       0
>      / \
>    -3   9
>    /   /
>  -10  5
> ```

```java
class Solution {
   public TreeNode sortedListToBST(ListNode head){
        return buildTree(head,null);
    }
    public TreeNode buildTree(ListNode head,ListNode tail){
        TreeNode res=null;
        if(head==tail)
            return res;
    
        ListNode fastNode=head;
        ListNode slowNode=head;
        while(fastNode!=tail&&fastNode.next!=tail){
            slowNode=slowNode.next;
            fastNode=fastNode.next.next;
        }
        
        res=new TreeNode(slowNode.val);
        res.left=buildTree(head,slowNode);
        res.right=buildTree(slowNode.next,tail);
        return res;
    }
}
```



#### 【17】和为某一值的路径

```java
	// pathList存所有可能路径
	// path用来保存路径的数据结构 这儿用ArrayList模拟了栈的数据结构
	private ArrayList<ArrayList<Integer>> pathList = new ArrayList<ArrayList<Integer>>();
	private ArrayList<Integer> path = new ArrayList<>();
 
	public ArrayList<ArrayList<Integer>> findPath(TreeNode root, int sum) {
		if (root == null)
			return pathList;
		path.add(root.val);
		sum -= root.val;
		// 路径值等于0，且当前节点是叶子节点 则找到一条路径
		if (sum == 0 && root.left == null && root.right == null)
			// 每次找到路径都需要添加一个新的path 不可以直接加path成员变量 这是个引用，不然所有pathList的值都指向同一个path
			pathList.add(new ArrayList<Integer>(path));
		if (root.left != null)
			findPath(root.left, sum);
 
		if (root.right != null)
			findPath(root.right, sum);
		// 访问完当前节点 需要删除路径中最后一个节点，回退至父节点
		path.remove(path.size() - 1);
		return pathList;
	}
```



#### 【18】之字形打印二叉树

> 利用两个栈，注意进栈顺序，s1先左后右，s2先右后左

```java
public static ArrayList<ArrayList<Integer>> printTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        ArrayList<ArrayList<Integer>> result = new ArrayList<>();
        //存储奇层节点
        Stack<TreeNode> stackOne = new Stack<>();
        //存储偶层节点
        Stack<TreeNode> stackTwo = new Stack<>();
        stackOne.push(root);
        int level = 1;
        while (!stackOne.isEmpty() || !stackTwo.empty()) {
            ArrayList<Integer> temp = new ArrayList<>();
            if (level % 2 == 1) {
                while (!stackOne.isEmpty()) {
                    TreeNode current = stackOne.pop();
                    if (current != null) {
                        temp.add(current.val);
                        //注意先左后右
                        stackTwo.push(current.left);
                        stackTwo.push(current.right);
                    }
                }
            } else {
                while (!stackTwo.empty()) {
                    TreeNode current = stackTwo.pop();
                    if (current != null) {
                        temp.add(current.val);
                        stackOne.push(current.right);
                        stackOne.push(current.left);
                    }
                }
            }
            if (!temp.isEmpty()) {
                result.add(temp);
                level++;
            }
        }

        return result;
    }
```



### 6、其他

#### 【1】7瓶水1瓶有毒3只老鼠，怎么找有毒的水，再加个条件，必须要求第二天出结果

> - 思路：若无时间限制，可采用类似二分查找的思路；若要求第二天出结果，用二进制编码的思路
> - 参考回答：
>   - 二分查找思路，每次均分两组，每组各取一滴水混合成新溶剂喂给老鼠，继续对导致老鼠死亡的一组水进行同上操作。假如是第1瓶有毒，过程演绎如下，第一只老鼠死于前一堆（mid=(0+6)/2=3，即服用了第1、2、3、4瓶的混合溶剂），第二只老鼠死于前一堆（mid=(0+3)/2=1，即服用了第1、2瓶的混合溶剂），第三只老鼠随意试一瓶，根据服用后状态即可判断有毒的水。
>   - 二进制编码思路，对每瓶水二进制编码，所需编码位数正好为三位，将第一位是1的水混为新溶剂喂给第一个老鼠，以此类推，看三只老鼠服用状态（死亡=1，存活=0）得出对应的编码，找到对应的水即可。假如是第1瓶有毒，编码之后，让第一只老鼠服用第4、5、6、7瓶的混合溶剂，第二只老鼠服用第2、3、6、7瓶的混合溶剂，第三只老鼠服用第1、3、5、7瓶的混合溶剂，最终第一只和第二只老鼠存活，第三只老鼠死亡，对应编码为001，对应的水是第一瓶，故此瓶有毒。
>     **
>      第一瓶水 001
>      第二瓶水 010
>      第三瓶水 011
>      第四瓶水 100
>      第五瓶水 101
>      第六瓶水 110
>      第七瓶水 111
>      **



#### 【2】不用加减乘除做加法

```java
public static int add(int num1, int num2) {
        int sum;
        int carry;
        while (num2 != 0) {
            //不考虑进位
            sum=num1^num2;
            //考虑进位
            carry=(num1&num2)<<1;
            num1=sum;
            num2=carry;
        }
        return num1;
    }
```



#### 【3】n个骰子点数

> - **题目：**把n个骰子扔到地上，所有骰子朝上一面的点数之后为s. 输入n，打印出s所有可能的值出现的概率。（每个骰子6个面，点数从1到6）
>
> - **思路：**
>
>   - 总共出现6的n次幂种组合
>   - 最小的和是n
>   - 最大的和是6n
>   - 总共6n-n+1种可能
>
> - **解法：**
>
>   - 解法1：基于递归，时间效率不高(自顶向下分解)
>
>     - 递归的思想一般是分而治之，**把n个骰子分为第一个和剩下的n-1个**。先计算第一个骰子每个点数出现的次数，再计算剩余n-1个骰子出现的点数之和。求n-1个骰子的点数之的方法和前面讲的一样，即再次把n-1个骰子分成两堆------第一个和剩下的n-2个。n个骰子，每个骰子6个面，总共有6n个组合。这6n个组合之中肯定有重复的，我们知道其范围是n~6n,对于每种情况我们可以用缓存机制记录下来，每当其发生一次我们令其对应的单元加1。
>
>       我们定义一个长度为6n-n+1的数组，和为s的点数出现的次数保存到数组第s-n个元素里。为什么是6n-n+1呢？因为n个骰子的**和最少是n，最大是6n，**介于这两者之间的每一个情况都可能会发生，总共6n-n+1种情况。下面是java源码：
>
>       - n=1 循环次数6
>       - n=2 循环次数72
>       - n=3 循环次数468
>       - n=4 循环次数2844
>       - n=5 循环次数17160
>
>   - 解法2：基于循环，时间性能好
>
>     - **递归一般是自顶向下的分析求解**，而基于循环的方法则是自底向上。基于循环的一般需要更少的空间和更少的时间，性能较好，但是一般代码比较难懂。
>
>       开两行数组初始化为0，下一次投骰子的时候，假设第一个数组中的第n个数字表示骰子和为n出现的次数，那么此时和为n的骰子出现次数应该等于上一次循环中骰子点数和为**n-1,n-2,n-3,n-4,n-5,n-6**的次数总和，所以我们把**另一个数组**的第**n**个数字设为前一个数组对应的n-1,n-2,n-3,n-4,n-5,n-6之和
>
>       - 第j次掷骰子，和最小为j，小于j的情况是不可能发生的！所以另不可能发生的次数设置为0！
>       - 第j次掷骰子，和最小为j，最大为g_maxValue*j，做二层循环
>
> - **复杂度：**时间：O（），空间O（）

```java
//递归
public class ck {
    public static void main(String[] args) {
        PrintProbability(2);
    }

    //n是不变的，到时候可以把参数省略
    private static final int g_maxValue = 6;
    private static int count = 0;
    private static int[] result;

    //基于递归求骰子点数，时间效率不高
    public static void PrintProbability(int n) {
        if (n < 1) return;
        //最大的数字
        int maxSum = n * g_maxValue;
        //6n-n+1
        result = new int[maxSum - n + 1];
        //初始化，开始统计之前都为0次
        for (int i = n; i <= maxSum; i++) {
            result[i - n] = 0;
        }
        //总共有多少种组合
        double total = Math.pow(g_maxValue, n);
        //probability(number,result);
        probability(n, result);
        //这个函数计算n~6n每种情况出现的次数
        for (int i = n; i <= maxSum; i++) {
            double ratio = result[i - n] / total;
            System.out.println("i: " + i + " ratio: " + ratio);
        }
        System.out.println("次数" + count);
    }

    public static void probability(int n, int[] result) {
        for (int i = 1; i <= g_maxValue; i++) {
            //循环6次，改变sum的值从1~6
            probability(n, n, i);
        }
    }

    /**
     * @param n       总共有多少骰子
     * @param current 当前第几个由n递减到1
     * @param sum     current个骰子的和 6次循环值从1~6
     */
    public static void probability(int n, int current, int sum) {
        //current==1时走此路
        if (current == 1) {
            //sum-n
            count++;
            result[sum - n]++; 				//关键点1
        } else {
            //计算抛去一个后的n-1个的可能性
            for (int i = 1; i <= g_maxValue; i++) {
                probability(n, current - 1, sum + i);   	//关键点2
                count++;
            }
        }
    }
}
```

```java
//循环
//- 第j次掷骰子，和最小为j，小于j的情况是不可能发生的！所以另不可能发生的次数设置为0！
//- 第j次掷骰子，和最小为j，最大为g_maxValue*j，做二层循环
for (int j = 2; j <= n; j++) {
           //第j次掷骰子，和最小为j，小于j的情况是不可能发生的！所以另不可能发生的次数设置为0！
           for (int i = 0; i < j; i++) {
               result[1 - flag][i] = 0;
           }
           //第j次掷骰子，和最小为j，最大为g_maxValue*j
           for (int i = j; i <= g_maxValue * j; i++) {
               //初始化，因为这个数组要重复使用，上一次的值要清0
               result[1 - flag][i] = 0;
               for (int k = 1; k <= i && k <= g_maxValue; k++) {
                   //进行赋值的核心代码
                   result[1 - flag][i] += result[flag][i - k];
                   count++;
               }
           }
           //flag在0与1之间切换
           flag = 1 - flag;
       }
//########
public class ck {
    public static void main(String[] args) {
        probability(2);
    }

    private static int count = 0;
    private static int flag = 0;
    private static final int g_maxValue = 6;
    private static int[][] result;

    //基于循环求骰子点数
    public static void probability(int n) {
        if (n < 1) {
            return;
        }
        //初始化数组 2行6n+1列的数组,因为下面的i从1开始
        //两行数组来回切换用于省空间
        //每次都换一行数组做上一次
        result = new int[2][g_maxValue * n + 1];
        for (int i = 0; i < g_maxValue; i++) {
            result[0][i] = 0;
            result[1][i] = 0;
        }
        //当第一次抛掷骰子时，有6种可能，每种可能出现一次
        for (int i = 1; i <= g_maxValue; i++) {
            result[0][i] = 1;
        }
        // 从第二次开始掷骰子，假设第一个数组中的第n个数字表示骰子和为n出现的次数，
        // 在下一循环中，我们加上一个新骰子，此时和为n的骰子出现次数应该等于上一次循环中骰子点数和为
        // n-1,n-2,n-3,n-4,n-5，n-6的次数总和，
        // 所以我们把另一个数组的第n个数字设为前一个数组对应的n-1,n-2,n-3,n-4,n-5，n-6之和
        for (int j = 2; j <= n; j++) {
            //第j次掷骰子，和最小为j，小于j的情况是不可能发生的！所以另不可能发生的次数设置为0！
            for (int i = 0; i < j; i++) {
                result[1 - flag][i] = 0;
            }
            //第j次掷骰子，和最小为j，最大为g_maxValue*j
            for (int i = j; i <= g_maxValue * j; i++) {
                //初始化，因为这个数组要重复使用，上一次的值要清0
                result[1 - flag][i] = 0;
                for (int k = 1; k <= i && k <= g_maxValue; k++) {
                    //进行赋值的核心代码
                    result[1 - flag][i] += result[flag][i - k];
                    count++;
                }
            }
            //flag在0与1之间切换
            //1-flag是当前要计算的，flag是上次的
            flag = 1 - flag;
        }

        //计算最终结果
        double total = Math.pow(g_maxValue, n);
        for (int i = n; i <= g_maxValue * n; i++) {
            double ratio = result[flag][i] / total;
            System.out.println("sum: " + i + " ratio: " + ratio);
        }
        System.out.println("次数" + count);
    }
}
```



#### 【4】2的幂

> - **题目：**给定一个整数，编写一个函数来判断它是否是 2 的幂次方
> - **思路：**
>   - 2的幂形如 10000000
>   - 2的幂-1 形如0111111
>   - 二者&运算结果为0

```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n<=0){
            return false;
        }
        return (n&n-1)==0;
    }
}
```



#### 【5】二进制表示中1的个数

> 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

```java
 public int NumberOf1(int n) {
        int count = 0;
        int flag = 1;
        while(flag != 0){
            if((n & flag) != 0){
                count ++;
            }
            flag = flag << 1;
        }
        return count;
    }
//解法2
每次减少传进来的数对应的二进制的一个1： 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1， 而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作
 public int NumberOf1(int n) {
        int count = 0;
        while(n != 0){
            count ++;
            n = n & (n-1);
        }
        return count;
    }
```



- **题目：**
- **思路：**

- **复杂度：**时间：O（），空间O（）

### 链接

- 《剑指Offer》
- LeetCode

- https://www.jianshu.com/p/9648e8dd5bdb



